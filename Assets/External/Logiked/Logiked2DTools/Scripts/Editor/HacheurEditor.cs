#if UNITY_EDITOR

using logiked.source.editor;
using logiked.Tool2D.animation;
using logiked.Tool2D.settings;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEditor;
using UnityEngine;
using logiked.Tool2D.editor;
using logiked.source.extentions;
using Object = UnityEngine.Object;
using UnityEngine.Assertions;
using System.Text.RegularExpressions;
using static logiked.Tool2D.editor.TextureMetadataExtension;
using UnityEditor.Presets;
using logiked.source.utilities;
using static logiked.Tool2D.animation.Animation2DFileVariations;

public partial class HacheurEditor : Logiked_EditorWindow
{


    /// TODO :
    /// Les labels des datas ne sont pas mis à jour automatiquement si le nom des fichiers est changé. 
    /// Utiliser Obj.UpdateLabel(GeneratedObjectsLabel, DatasLabel_UniquePrefix); surt tout les assets en cas de modif
    /// 
    ///
    ///




    #region INSTANTIATION

    [MenuItem("Logiked/Hacheur Window", priority = 1001)]
    static void CreateHacheurFromMenu()
    {
        if (!CreateHacheurValidation())
        {
            EditorUtility.DisplayDialog("Cannot open Hacheur", "You must select a Texture 2D in the project before using Hacheur Window.", "Ok");
            return;
        }
        CreateHacheur();
    }

    private const string menuItemPath = LogikedPlugin_2DTools.MenuItemName + "Open Hacheur Window %h";

    [MenuItem(menuItemPath, priority = LogikedProjectConfig.LogikedMenuItemPriority)]
    static void CreateHacheur()
    {
        AssetDatabase.Refresh();
        HacheurEditor window = (HacheurEditor)GetWindow(typeof(HacheurEditor));
        window.SetTexture((Texture2D)Selection.activeObject);
        window.InitVars();
        window.Show();
    }

    [MenuItem(menuItemPath, true)]
    static bool CreateHacheurValidation()
    {


        if (Selection.activeObject is Texture2D)       
            return true;


        if (Selection.activeObject is Animation2DFile)
        {
            Animation2DFile anim =  (Animation2DFile)Selection.activeObject;

            var texs = anim.Sprites.Where(m => m != null).Select(m => m.texture);
            texs = texs.Distinct();

            if (texs.Count() == 1)
            {
                Selection.activeObject = texs.First();
                return true;
            }

        }


        return false;
    }


    #endregion

    #region FIELDS Redefinition
    protected override string DatasLabel_UniquePrefix => "tex_";
    protected override string DatasLabel_Postfix => text2d.name;
    #endregion 

    #region FIELDS Editor

    TextureImporter textureImport;

    /// <summary>
    //Path de la texeture
    /// </summary>
    private string texturePath;

    private string textureDir => Path.GetDirectoryName(texturePath);

    /// <summary>
    //Path des donnés associés à la texture (animations, materials...) .../nomTex_datas/
    /// </summary>
    private string currentDataPath
    {
        get
        {
            var val = AssetDatabase.GetAssetPath(animationFolder);
            return val.IsNullOrEmpty() ? Path.GetDirectoryName(AssetDatabase.GetAssetPath(text2d)) : val;
        }
    }

    //Paths
    private string anim_autoGeneratedDataPath => Path.Combine(Path.GetDirectoryName(text2d.GetAssetPath(Logiked_AssetsExtention.PathFormat.AssetRelative)), Path.GetFileNameWithoutExtension(text2d.name) + "_datas");



    string dataPrefix;

    Vector2 bottomBarScroll;

    /// <summary>
    /// La texture
    /// </summary>
    private Texture2D text2d;

    /// <summary>
    /// Mode de l'editeur
    /// </summary>
    private EditMode selectedTool = EditMode.NotSet;
    /// <summary>
    /// Liste des différents modes disponnibles
    /// </summary>
    [System.NonSerialized]
    private Dictionary<EditMode, SpriteEditTool> toolList = new Dictionary<EditMode, SpriteEditTool>();

    #endregion

    #region FIELDS Selection/Drawing sprite rects
    private Texture2D backgroundImg;//Decorative
    private Texture2D spriteBorderTex;

    /// <summary>
    ///Zone rectangulaire alloué pour l'edition et l'affichage de la texture.
    /// </summary>
    private Rect imageAllocRect;
    /// <summary>
    ///Position reele d'affichage de la texture.
    /// </summary>
    private Rect imageDrawingRect;

    private Rect headerBarRect => new Rect(0, 0, position.width, 25);


    /// <summary>
    /// Est ce que la souris effectue un Cick gauche en drag ?
    /// </summary>
    private bool isMouseDraggingForSelection = false;

    private Vector2 mouseDragSelectionStart;
    private Vector2 mouseDragSelectionEnd;

    private bool isMouseOverTextureArea { get => imageAllocRect.Contains(Event.current.mousePosition) && !headerBarRect.Contains(Event.current.mousePosition) && !isMouseOverInspector; }
    //private bool isMouseOverTexture { get => imageDrawingRect.Contains(Event.current.mousePosition); }
    private bool isMouseOverInspector { get => inspectorWindow.Contains(Event.current.mousePosition); }

    private Vector2 dragScrollPosition = Vector2.zero;
    private Vector2 imageOffsetTrue;

    private float zoomCoef = 1;
    private Vector2 defaultWinSize = new Vector2(350, 500);


    private Vector2 inspectorScrollPosition;
    private Rect inspectorWindow => new Rect(position.width - 255, 28, 250, 60 + selectedSprites.Count * 60);


    /// <summary>
    /// List of all edited sprites
    /// </summary>
    [SerializeField] private List<SpriteMetaExtended> spritesAll = new List<SpriteMetaExtended>();
    [System.NonSerialized] private HashSet<SpriteMetaExtended> selectedSprites = new HashSet<SpriteMetaExtended>();
    [System.NonSerialized] private List<SpriteMetaExtended> selectedSpritesSorted = new List<SpriteMetaExtended>();

    #endregion


    #region FIELDS  INPUTS
    bool input_holdCtrl { get => Event.current.modifiers.HasFlag(EventModifiers.Control); }
    bool input_holdAlt { get => Event.current.modifiers.HasFlag(EventModifiers.Alt); }
    bool input_holdShift { get => Event.current.modifiers.HasFlag(EventModifiers.Shift); }
    KeyCode input_frameKeyDown { get => Event.current.type == EventType.KeyDown ? Event.current.keyCode : KeyCode.None; }
    #endregion

    #region FIELDS GUI
    private Color spriteBorderColor = new Color(1, 1, 1, 1f);
    private Color spriteOverColor = new Color(0, 1, 1, 0.9f);
    private Color spriteSelectColor = new Color(0, 0.6f, 1, 1f);
    private Color spriteAnimationColor = new Color(1f, 0f, 1f, 0.5f);
    private Color spriteDirectionnalColor = new Color(1f, .5f, 0f, 0.75f);
    private Color blackBackground = new Color(1f, 1f, 1f, 0.5f);
    private Color greySoftBackground = new Color(1f, 1f, 1f, 0.1f);


    /// <summary>
    /// Faut-til repeindre la fenettre à la prochaine frame ?
    /// </summary>
    private bool needRepaint;
    #endregion




    #region FIELDS A detruire
    void UpdateSortedSprites()//shit à modifier
    {
        selectedSpritesSorted = selectedSprites.ToList();
        selectedSpritesSorted.Sort((x, y) => x.datas.name.CompareTo(y.datas.name));
    }

    string buttonText;
    string randomKebabText
    {
        get
        {
            switch (UnityEngine.Random.Range(0, 5))
            {
                case 0: return "Tranchez moi ça !";
                case 1: return "C'est parti boucher !";
                case 2: return "Et que ça tranche !";
                case 3: return "Tranchez Capitaine !";
                default: return "à la boucherie !";
            }
        }
    }

    #endregion

    #region FIELDS hacheur tools
    private int sliceX { get => datas.Cut_ValueX; set => datas.Cut_ValueX = value; }
    private int sliceY { get => datas.Cut_ValueY; set => datas.Cut_ValueY = value; }
    private float pivotX { get => datas.Cut_PivotX; set => datas.Cut_PivotX = value.Clamp01(); }
    private float pivotY { get => datas.Cut_PivotY; set => datas.Cut_PivotY = value.Clamp01(); }
    private bool useSpriteCount { get => datas.Cut_useCountInsteadPixels; set => datas.Cut_useCountInsteadPixels = value; }
    private bool keepEmptySprites { get => datas.Cut_keepEmptySprites; set => datas.Cut_keepEmptySprites = value; }
    private int columnCount { get => datas.Cut_columnCount; set => datas.Cut_columnCount = value; }

    #endregion

    #region CLASSES


    private class SpriteEditTool
    {
        public string name;
        public Action action;
        public Action initTool;
        public Action closeTool;
        public SpriteEditTool(string name, Action action, Action initTool, Action closeTool) { this.name = name; this.action = action; this.initTool = initTool; this.closeTool = closeTool; }
    }

    enum EditMode { NotSet, Cut, Animation, Format }

    /// <summary>
    /// Extention class for SpriteMetaData
    /// </summary>
    [System.Serializable]
    public class SpriteMetaExtended
    {
        [SerializeField] public SpriteMetaData datas;
        //Event params
        [SerializeField] public Rect guiTextureRect;
        [SerializeField] public Rect screenRect;
        [SerializeField] public bool isSelected;
        [SerializeField] public bool isMouseOver;
        [SerializeField] public bool isAnimSelected;
        [SerializeField] public bool isDirectionnalSelected;

        //Call LinkMetaToSprite() to update
        [NonSerialized] public Sprite linkedSpriteFile;
    }


    #endregion


    #region EDITOR INIT & System

    /// <summary>
    /// Init all fields
    /// </summary>
    public void InitVars()
    {
        GUIUtility.hotControl = 0;

        buttonText = randomKebabText;

        if (spritesAll.Count > 0) {
            UpdateSpriteData(spritesAll[0]);
        }



        spriteBorderTex = new Texture2D(1, 1);
        spriteBorderTex.SetPixel(0, 0, Color.white);
        spriteBorderTex.wrapMode = TextureWrapMode.Clamp;
        spriteBorderTex.filterMode = FilterMode.Point;
        spriteBorderTex.Apply();

        InitToolList();
    }

    /// <summary>
    /// Generates the tool list.
    /// </summary>
    void InitToolList()
    {
        toolList.Clear();
        toolList.Add((EditMode)1445, new SpriteEditTool("Import settings", DrawFormatTool, DrawFormatTool_Init, null));
        toolList.Add(EditMode.Cut, new SpriteEditTool("Sprite cutter", DrawCuttingTool, null, null));
        toolList.Add(EditMode.Animation, new SpriteEditTool("Animations", DrawAnimationTool, InitAnimationTool, CloseAnimationTool));
        toolList.Add(EditMode.Format, new SpriteEditTool("Other", DrawWorkspaceTool, DrawWorkspaceTool_Init, null));

        if (selectedTool == EditMode.NotSet)
            SetEditMode(EditMode.Cut);
        toolList[selectedTool].closeTool?.Invoke();//Restart current tool
        toolList[selectedTool].initTool?.Invoke();
    }

    /// <summary>
    /// Sets the current edition mode (it modify displayed tools).
    /// </summary>
    void SetEditMode(EditMode mode)
    {
        selectedTool = mode;
    }

    /// <summary>
    /// Search assets in the texture data folder.
    /// </summary>
    private List<T> GetAssetsFromDataFolder<T>(string search) where T : UnityEngine.Object
    {
        if (!Directory.Exists(currentDataPath)) return null;
        List<T> end = new List<T>();
        var files = AssetDatabase.FindAssets(search, new string[] { currentDataPath });
        foreach (var f in files)
            end.Add((T)AssetDatabase.LoadAssetAtPath(AssetDatabase.GUIDToAssetPath(f), typeof(T)));

        return end;
    }

    /// <summary>
    /// Save assets in the texture data folder.
    /// </summary>
    /// <param name="obj">The object.</param>
    /// <param name="extention">Thanks to specify the dot, ".asset" for example.</param>

    private void SaveAssetsToDataFolder(UnityEngine.Object obj )
    {
        //  if (!Directory.Exists(currentDataPath))
        //       CreateDataFolder();

        string path = Path.Combine(currentDataPath, dataPrefix) + obj.name + ".asset";
        if (!File.Exists(path))
            AssetDatabase.CreateAsset(obj, path);
        UpdateAssetLabel(obj);

        EditorUtility.SetDirty(obj);
        AssetDatabase.SaveAssets();
        AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);

        RefreshAnimationFiles();
    }

    private void RemoveAssetFromDataFolder(UnityEngine.Object obj)
    {

        AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(obj));
        AssetDatabase.SaveAssets();
    }

    private void RemameAssetFromDataFolder(UnityEngine.Object obj, string newName)
    {
        string orig = AssetDatabase.GetAssetPath(obj);
        AssetDatabase.RenameAsset(orig, newName);
        obj.name = newName;
        //AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
        // Debug.LogError(orig + "\n" + path);

    }





    /// <summary>
    /// Create the data folder
    /// </summary>
    void CreateDataFolder(string folderPath)
    {
        if (!AssetDatabase.IsValidFolder(folderPath))
        {
            AssetDatabase.CreateFolder(Path.GetDirectoryName(folderPath), Path.GetFileName(folderPath));
            AssetDatabase.Refresh();
            AssetDatabase.ImportAsset(folderPath);

            datas.Anim_folderId = AssetDatabase.AssetPathToGUID(folderPath);

        }
    }

    /// <summary>
    /// Search sprite by name. Catastrophic O(n)
    /// </summary>
    private SpriteMetaExtended GetSpriteByName(string name)
    {
        for (int i = 0; i < spritesAll.Count; i++)
            if (spritesAll[i].datas.name == name) return spritesAll[i];
        return null;
    }

    /// <summary>
    /// Draw a Stylized black vertical Area for tools 
    /// </summary>
    void BeginVerticalToolPanel(string label, float width, GenericMenu contextGear = null, Action otherIcons = null, bool expandHeight = true)
    {

        GUI.color = blackBackground;
        GUILayout.BeginVertical(GUILogiked.Styles.Box_OpaqueWindowDark, GUILayout.Width(width), GUILayout.ExpandHeight(expandHeight));
        GUI.color = Color.white;
        GUILayout.BeginHorizontal();
        GUILayout.Label(label, GUILogiked.Styles.Text_BigBold);

        if (otherIcons != null)
            otherIcons();
        if (contextGear != null) GUILogiked.Panels.GUIDrawEditorIcon(contextGear);

        GUILayout.EndHorizontal();
        GUILayout.Space(5);
    }



    #endregion

    #region EDITOR Texture Interaction

    [SerializeField]
    TextureMetadataExtension datas;

    void RefreshImporterAndDatas()
    {
        Debug.Log("refeshed");
        textureImport = AssetImporter.GetAtPath(text2d.GetAssetPath(Logiked_AssetsExtention.PathFormat.AssetRelative)) as TextureImporter;
        datas = TextureMetadataExtension.DeserializeFromImporter(textureImport, false);


        if (datas == null)
        {
           // Debug.Log("New datas");
            //New TextureMetadataExtension created
            datas = new TextureMetadataExtension(textureImport);

            //Assign default animation folder if animation already created in sub-dirs
            var assets = AssetDatabase.FindAssets("t:Animation2DFile", new string[] { textureDir });
            string animDir;
            foreach (var guid in assets)
            {
                animDir = Path.GetDirectoryName(AssetDatabase.GUIDToAssetPath(guid));
                if (animDir != textureDir)
                {
                    datas.Anim_folderId = AssetDatabase.AssetPathToGUID(animDir);
                }
            }
            //New TextureMetadataExtension created

        }

        SaveMetaDatas();
    }

    void SaveMetaDatas()
    {
        if (textureImport == null || datas == null) return;
        datas.Serialize();
    }






    public void SetTexture(Texture2D tex)
    {
        text2d = tex;
        this.texturePath = tex.GetAssetPath(Logiked_AssetsExtention.PathFormat.AssetRelative);
        this.dataPrefix = text2d.name + "_";
        UpdateAssetLabel(text2d);



        SaveMetaDatas();
        RefreshImporterAndDatas();


        ///  backgroundImg = (Texture2D)AssetDatabase.LoadAssetAtPath("Assets/Scripts/LogikedAssemblies/Logiked2DTools/Editor/hacheurBackgroundUi.png", typeof(Texture2D));



        //Clear sprites
        spritesAll.Clear();
        selectedSprites.Clear();






        if (textureImport == null) Close();

        textureImport.isReadable = true;

        AutoFormat(true);

        LoadSpritesFromTexture();

        ResetZoom();


        if (selectedTool == EditMode.Animation && selectedAnimation != null)
            UpdateAnimationHilightSprites();
    }



    void LoadSpritesFromTexture()
    {

        var sprites = textureImport.spritesheet;
        spritesAll.Clear();
        foreach (var s in sprites)
            spritesAll.Add(GenerateSpriteDatas(s));
        LinkMetaToSprite(spritesAll, texturePath);
    }

    private static void LinkMetaToSprite(List<SpriteMetaExtended> metas, string texturePath)
    {
        Sprite[] sprites = AssetDatabase.LoadAllAssetsAtPath(texturePath).OfType<Sprite>().ToArray();
        Dictionary<string, Sprite> dic = new Dictionary<string, Sprite>();
        for (int i = 0; i < sprites.Length; i++) dic.Add(sprites[i].name, sprites[i]);
        for (int i = 0; i < metas.Count; i++) if (dic.ContainsKey(metas[i].datas.name)) metas[i].linkedSpriteFile = dic[metas[i].datas.name];


    }



    private static SpriteMetaExtended GenerateSpriteDatas(SpriteMetaData meta)
    {
        SpriteMetaExtended s = new SpriteMetaExtended();
        s.datas = meta;
        return s;
    }

    void UpdateSpriteData(SpriteMetaExtended sprite)
    {
        var data = sprite.datas;
        var coefScale = imageDrawingRect.size.Divide(text2d.width, text2d.height);

        #region Sprite render computation

        var screenRect = data.rect;
        screenRect.position += Vector2.up * screenRect.height;
        screenRect.position *= coefScale.Multiply(1, -1f);
        screenRect.position += imageOffsetTrue - (((imageAllocRect.size) * 0.5f - imageOffsetTrue) * (zoomCoef - 1));
        screenRect.y = (screenRect.y) + imageAllocRect.min.y + imageDrawingRect.height;//Décale l'image vers le bas

#if PC_CHAUCO        
        screenRect.y +=  imageAllocRect.height * (text2d.height / text2d.width) * zoomCoef ;//En fonction du ration de Fit de l'image
#endif

        screenRect.size *= coefScale;
        sprite.screenRect = screenRect;

        var guiTextureRect = new Rect(data.rect);
        guiTextureRect.xMin /= text2d.width;
        guiTextureRect.xMax /= text2d.width;
        guiTextureRect.yMin /= text2d.height;
        guiTextureRect.yMax /= text2d.height;
        sprite.guiTextureRect = guiTextureRect;

        #endregion

    }

    private static void SaveSpritesToTexture(List<SpriteMetaExtended> metas, Texture2D tex2D, TextureImporter textureImport)
    {

        SpriteMetaData[] datas = metas.Select(m => m.datas).ToArray(); ;


        //textureImport.spritesheet = new SpriteMetaData[0];
       // textureImport.SaveAndReimport();

        textureImport.spritesheet = datas;
        EditorUtility.SetDirty(textureImport);
        textureImport.SaveAndReimport();

        EditorUtility.FocusProjectWindow();
        LinkMetaToSprite(metas, tex2D.GetAssetPath(Logiked_AssetsExtention.PathFormat.AssetRelative));
    }

    #endregion


    public void OnGUI()
    {



        if (selectedTool == EditMode.NotSet || toolList.Count == 0 || spriteBorderTex == null)
        {
            if (textureImport == null) { Close(); return; }

            InitVars();
            LoadSpritesFromTexture();
        }


        if (text2d == null)
            Close();


        minSize = new Vector2(300, 400);
        maxSize = Vector2.one * 1500f;
        Color saveColor = GUI.color;




        //  if (backgroundImg != null)//Decorature
        //      GUI.DrawTexture(new Rect(-position.width * 0.1f, -position.height * 0.2f, position.width * 1.2f, position.width * 1.2f), backgroundImg, ScaleMode.ScaleToFit, true, 0F);



        /*
        GUILayout.Space(10);
        GUILayout.BeginHorizontal();
        GUILayout.EndHorizontal();
        GUILayout.Space(5);
        */



        GUILayout.BeginVertical();

        imageAllocRect = GUILayoutUtility.GetRect(position.width / 1.5f, position.height / 1.5f);
        imageDrawingRect = imageAllocRect;


        //Placement de la texture
        imageDrawingRect.size = new Vector2(imageAllocRect.width * (imageAllocRect.height / imageAllocRect.width), imageAllocRect.height);//Addaptation de la largeur de l'image. Ca la décale a gauche. 
        imageDrawingRect.size *= new Vector2(1, (float)text2d.height / (float)text2d.width);

        imageOffsetTrue = dragScrollPosition + new Vector2((imageAllocRect.width - imageDrawingRect.width) / 2f, 0);//Add drag + Decalage a droite pour centrer l'image

        imageDrawingRect.position += imageOffsetTrue - (((imageAllocRect.size) * 0.5f - imageOffsetTrue) * (zoomCoef - 1)); // Gestion centrée du zoom

        imageDrawingRect.size *= zoomCoef;



        //Affichage de la texture
        EditorGUI.DrawRect(imageDrawingRect, greySoftBackground);//Background
        GUI.DrawTexture(imageDrawingRect, text2d, ScaleMode.ScaleToFit, true, 0F);
        GUILayout.EndVertical();




        SelectEventSprites();
        DrawSpriteOutlines();
        MouseNavigation();



        BeginWindows();



        ///Header bar + Config Gear
        GUI.color = Color.black + Color.white * 0.1f;
        var shortcuts = GetWorkspaceContextMenu();
        GUI.Window(22, headerBarRect, (x) => DrawHeaderBar(shortcuts), "", GUILogiked.Styles.Box_OpaqueWhite);
        GUI.color = Color.white;


        if (Event.current.type != EventType.Repaint)//Pour actualiser seulement sur 1 event
            UpdateSortedSprites();

        if (selectedSpritesSorted.Count > 0)
            GUI.Window(30, inspectorWindow, DrawInspectorWindow, "Selected sprites");

        DrawToolArea();


        EndWindows();



        if (needRepaint)
            Repaint();
        needRepaint = false;
    }




    GenericMenu GetWorkspaceContextMenu()
    {
        GenericMenu mainInspectorGear = new GenericMenu();
        mainInspectorGear.AddItem(new GUIContent("Reveal Texture file"), false, () => ProjectBrowserReflection.SelectAssetInProjectWindow(text2d));
        mainInspectorGear.AddShortcut(KeyCode.F1, EventModifiers.Control);
        mainInspectorGear.AddSeparator("");

        // mainInspectorGear.AddItem(new GUIContent("Create Animation"), selectedSprites.Count > 1, CreateAnimationpressed);

        mainInspectorGear.AddItem(new GUIContent("Cut and Update Animations"), false, CutAndUpdateAnimationsSprites);

        CreateAnimationButton_FillContextMenu(mainInspectorGear, "Create Animation/");


        // mainInspectorGear.AddShortcut(KeyCode.C, EventModifiers.Control);


        mainInspectorGear.AddItem(new GUIContent("Select all"), false, () => { foreach (var e in spritesAll) SelectSpriteAdd(e, false); });
        mainInspectorGear.AddShortcut(KeyCode.A, EventModifiers.Control);



        return mainInspectorGear;
    }

    void DrawHeaderBar(GenericMenu shortcutMenu)
    {

        GUILayout.BeginHorizontal();

        GUILogiked.Panels.GUIDrawEditorIcon(shortcutMenu);


        if (GUILayout.Button(texturePath + " [" + text2d.width + "x" + text2d.height + "]", GUILogiked.Styles.Button_NoBackgroundButton, GUILayout.Height(16)))
        {
            ProjectBrowserReflection.SelectAssetInProjectWindow(text2d);
        }
        GUILayout.EndHorizontal();

    }


    bool isDragging = false;
    Vector2 lastMousePosition;
    Vector2 startDragPosition;

    void MouseNavigation()
    {


        int controlId = GUIUtility.GetControlID(FocusType.Passive);

        Event evt = Event.current;

        var envtType = evt.GetTypeForControl(controlId);

        if (EditorWindow.focusedWindow == this && EditorWindow.mouseOverWindow == this)
        {
            if (isMouseOverTextureArea)
            {

                switch (envtType)
                {


                    case EventType.MouseDown:

                        if (evt.button != 1 && evt.button != 2) break;

                        isDragging = true;
                        startDragPosition = evt.mousePosition;
                        GUIUtility.hotControl = controlId;
                        evt.Use();
                        break;


                    case EventType.MouseUp:

                        if (evt.button != 1) break;

                        if (Vector2.Distance(evt.mousePosition, startDragPosition) < 10)//Si l'utilisateur a quasiement pas bougé
                        {
                            ShowRightClickNavigationContext();
                        }

                        break;



                    case EventType.ScrollWheel:

                        zoomCoef -= Event.current.delta.y * 0.025f * zoomCoef;
                        zoomCoef = Mathf.Clamp(zoomCoef, 0.3f, 16f);
                        break;




                }



            }
        }





        if (isDragging)
        {
            var delta = Event.current.mousePosition - lastMousePosition;

            needRepaint = true;
            dragScrollPosition += delta / zoomCoef;

            if (envtType == EventType.MouseUp)
            {
                isDragging = false;
            }
        }






        lastMousePosition = evt.mousePosition;

    }


    void ResetZoom()
    {
        dragScrollPosition = new Vector2(0, position.height / 4f);
        zoomCoef = 1f;
    }

    void ShowRightClickNavigationContext()
    {
        GenericMenu menu = new GenericMenu();

        menu.AddItem(new GUIContent("Reset zoom"), ResetZoom);

        menu.ShowAsContext();
    }


    #region TOOLS

    #region TOOLS - Main Panel

    void DrawToolArea()
    {
        var saveColor = GUI.color;

        GUI.color = new Color(0.075f, 0.075f, 0.075f, 0.8f);
        GUILayout.BeginVertical(GUILogiked.Styles.Box_OpaqueWhite, GUILayout.ExpandWidth(true));
        GUILayout.Space(5);
        GUI.color = saveColor;

        GUILayout.BeginHorizontal();

        GUILayout.Space(10);
        EditorGUILayout.LabelField("Mode", GUILogiked.Styles.Text_BigBold, GUILayout.Width(50));
        GUILayout.Space(10);



        foreach (var tool in toolList)
        {
            if (selectedTool == tool.Key)
                GUI.enabled = false;
            if (GUILayout.Button(tool.Value.name, GUILayout.Width(100)))
            {
                toolList[selectedTool].closeTool?.Invoke();
                tool.Value.initTool?.Invoke();

                selectedTool = tool.Key;
            }
            GUI.enabled = true;
        }

        GUILayout.FlexibleSpace();




        GUILayout.EndHorizontal();

        bottomBarScroll = GUILayout.BeginScrollView(bottomBarScroll, false, false);

        GUILayout.Space(5);


        toolList[selectedTool].action();

        GUILayout.EndScrollView();


        GUILayout.FlexibleSpace();
        GUILayout.EndHorizontal();
    }

    #endregion

    #region TOOLS - Sprite cutter

    void DrawCuttingTool()
    {
        GUILayout.BeginHorizontal();

        GUILayout.BeginVertical();

        GUILayout.BeginHorizontal();
        DrawCuttingToolSettings();
        DrawCuttingToolOtherSettings();
        GUILayout.EndHorizontal();

        if (GUILayout.Button(buttonText, GUILayout.Height(30)))
        {
            CutAndUpdateAnimationsSprites();
        }
        GUILayout.EndVertical();
        GUILayout.FlexibleSpace();
        GUILayout.EndHorizontal();


    }

    void DrawCuttingToolSettings()
    {

        BeginVerticalToolPanel("Cut Settings", 180);

        EditorGUIUtility.labelWidth = 130f;

        useSpriteCount = PropertyDrawerFinder.DrawPropertyOject(useSpriteCount, new GUIContent("Use sprite count"), null);

        if (!useSpriteCount)
        {
            sliceX = PropertyDrawerFinder.DrawPropertyOject(sliceX, new GUIContent("Sprites size X"), null);
            sliceY = PropertyDrawerFinder.DrawPropertyOject(sliceY, new GUIContent("Sprites size Y"), null);
        }
        else
        {
            sliceX = PropertyDrawerFinder.DrawPropertyOject(sliceX, new GUIContent("Sprites count X"), null);
            sliceY = PropertyDrawerFinder.DrawPropertyOject(sliceY, new GUIContent("Sprites count Y"), null);
        }

        GUILayout.BeginHorizontal();
        EditorGUILayout.LabelField("Pivot X-Y");
        pivotX = EditorGUILayout.FloatField(pivotX, GUILayout.Width(29));
        pivotY = EditorGUILayout.FloatField(pivotY, GUILayout.Width(29));
        GUILayout.EndHorizontal();





        GUILayout.EndVertical();



        /*
        if (GUILayout.Button("C'est terminé capitaine." , GUILayout.Height(30),GUILayout.Width(220)))
        {
            Close();
        }*/
    }




    void DrawCuttingToolOtherSettings()
    {

        BeginVerticalToolPanel("Other Settings", 180);


        keepEmptySprites = PropertyDrawerFinder.DrawPropertyOject(keepEmptySprites, new GUIContent("Keep empty sprites"), null);
        columnCount = PropertyDrawerFinder.DrawPropertyOject(columnCount, new GUIContent("Column count"), null);


        GUILayout.Space(5);


        GUILayout.EndVertical();

    }



    /// <summary>
    /// Cut the texture and save it
    /// </summary>
    public static List<SpriteMetaExtended> CuttingTool_HachTex(Texture2D texture, TextureMetadataExtension cuttingParams, TextureImporter textureImport)
    {
        var datas = cuttingParams;
        var useSpriteCount = cuttingParams.Cut_useCountInsteadPixels;
        var sliceX = cuttingParams.Cut_ValueX;
        var sliceY = cuttingParams.Cut_ValueY;
        var pivotX = cuttingParams.Cut_PivotX;
        var pivotY = cuttingParams.Cut_PivotY;
        var keepEmptySprites = cuttingParams.Cut_keepEmptySprites;


        int i, j;
        string texName = texture.name;
        List<SpriteMetaExtended> newDatas = new List<SpriteMetaExtended>();


        if (textureImport.spriteImportMode != SpriteImportMode.Multiple)
        {
            textureImport.spriteImportMode = SpriteImportMode.Multiple;
            textureImport.SaveAndReload();
        }


        var sliceXSize = useSpriteCount ? (texture.width / sliceX) : sliceX;
        var sliceYSize = useSpriteCount ? (texture.height / sliceY) : sliceY;


        Vector2Int totSiz = new Vector2Int(Mathf.FloorToInt((float)texture.width / (float)sliceXSize), Mathf.FloorToInt((float)texture.height / (float)sliceYSize));

        string formatX = "000";//new string('0', Mathf.Log10((float)totSiz.x).Ceil());
        string formatY = "000";//new string('0', Mathf.Log10((float)totSiz.y).Ceil() );
        
        int nameIndexX = 0;
        int nameIndexY = 0;

        int columnSize = (totSiz.x / datas.Cut_columnCount);



        for (j = 0; j < totSiz.x; j++)
        {
            for (i = 0; i < totSiz.y; i++)
            {

                SpriteMetaData smd = new SpriteMetaData();

                if (pivotX == 0.5f && pivotY == 0.5f)
                {
                    smd.pivot = new Vector2(0.5f, 0.5f);
                    smd.alignment = 0;
                }
                else
                {
                    smd.alignment = 9;//0;
                    smd.pivot = new Vector2(pivotX, pivotY);
                }

                nameIndexX = (totSiz.y - 1) - i;
                nameIndexX = nameIndexX + (j / columnSize) * totSiz.y;

                nameIndexY = j;
                nameIndexY %= columnSize;



                nameIndexY += 1;//Sprites starts at [1]
                nameIndexX += 1;//Sprites starts at [1]


                smd.name = texName + "_" + nameIndexX.ToString(formatY) + "_" + nameIndexY.ToString(formatX);
                Debug.Log(smd.name);


                smd.rect = new Rect(j * sliceXSize, i * sliceYSize, sliceXSize, sliceYSize);

                smd.rect.xMax = smd.rect.xMax.Clamp((float)texture.width);
                smd.rect.yMax = smd.rect.yMax.Clamp((float)texture.height);

                if (keepEmptySprites || !CheckEmpty(smd.rect, texture))
                {
                    newDatas.Add(GenerateSpriteDatas(smd));
                }

            }
        }


        // Selection.activeObject = null;
        SaveSpritesToTexture(newDatas, texture, textureImport);
        return newDatas;

    }


    /// <summary>
    /// Checks if the pixel rect is empty on the texture.
    /// </summary>
    private static bool CheckEmpty(Rect check, Texture2D text2d)
    {
        Color ch;

        for (int x = 0; x < check.width; x++)
        {
            for (int y = 0; y < check.height; y++)
            {
                ch = text2d.GetPixel(x + (int)check.x, y + (int)check.y);

                if (ch.a > 0.1f)
                    return false;
            }
        }
        return true;
    }
    #endregion

    #region TOOLS - Sprite animator

    float animationPreviewTimer;
    long saveMillis;
    Animation2DFile selectedAnimation;
    //Inspector_Animation2DFile selectedAnimationEditor;
    Animation2DReader animationPreviewReader = null;


    Vector2 animationInspectorScrollView;
    Vector2 animationFilesScrollView;

    void InitAnimationTool()
    {
        selectedAnimation = null;
    //    selectedAnimationEditor = null;
        animationInspectorScrollView = Vector2.zero;
        animationFilesScrollView = Vector2.zero;


        RefreshAnimationFiles();
    }

    void CloseAnimationTool()
    {
        Animation_Select(null);
    }



    DefaultAsset animationFolder;


    void DrawAnimationTool()
    {

        DrawAnimFolderSection();


        GUILayout.BeginHorizontal(GUILayout.ExpandWidth(true));

        DrawAnimationFileList();
        if (selectedSprites.Count > 1)
        {
            var sprites = selectedSpritesSorted;
            DrawAnimationPreview(sprites);
        }

        if (selectedAnimation != null)
        {


            DrawAnimationProcessor();
            DrawArrow();
            DrawAnimationInspector();
        }

        GUILayout.EndHorizontal();
    }



    void DrawArrow()
    {
        GUILayout.BeginVertical(GUILayout.ExpandHeight(false), GUILayout.Width(20f));
        GUILayout.FlexibleSpace();
        GUILayout.Label("➡");
        GUILayout.FlexibleSpace();
        GUILayout.EndVertical();
    }

    List<Animation2DFile> dataFolderAnimationsFiles;

    void RefreshAnimationFiles()
    {
        var folder = datas.Anim_folderId;
        if (folder != null)
            animationFolder = AssetDatabase.LoadAssetAtPath<DefaultAsset>(AssetDatabase.GUIDToAssetPath(folder));
        else
            animationFolder = null;

        dataFolderAnimationsFiles = GetAssetsFromDataFolder<Animation2DFile>("t:" + typeof(Animation2DFile).Name);
    }


    void DrawAnimFolderSection()
    {
        GUILayout.BeginHorizontal(GUILayout.MaxWidth(300));

        GUILayout.Label("Animation folder");

        var folder = datas.Anim_folderId;
        if (folder != null)
            animationFolder = AssetDatabase.LoadAssetAtPath<DefaultAsset>(AssetDatabase.GUIDToAssetPath(folder));

        if (animationFolder == null)
            folder = null;

        EditorGUI.BeginChangeCheck();
        animationFolder = (DefaultAsset)EditorGUILayout.ObjectField(animationFolder, typeof(DefaultAsset), allowSceneObjects: false);

        if (!AssetDatabase.IsValidFolder(animationFolder.GetAssetPath(Logiked_AssetsExtention.PathFormat.AssetRelative))) animationFolder = null;

        datas.Anim_folderId = animationFolder?.GetGUID();

        if (EditorGUI.EndChangeCheck())
            RefreshAnimationFiles();

        GenericMenu folderSearch = new GenericMenu();


        folderSearch.AddItem(new GUIContent($"Use Texture's folder"), () =>
        {
            datas.Anim_folderId = null;
            animationFolder = null;
            RefreshAnimationFiles();
        }, checkmark: animationFolder == null);


        folderSearch.AddSeparator("");

        folderSearch.AddItem(new GUIContent($"Create folder [{Path.GetFileName(anim_autoGeneratedDataPath)}]"), () =>
            {
                CreateDataFolder(anim_autoGeneratedDataPath);
                RefreshAnimationFiles();
            }, isDisabledMenu: AssetDatabase.IsValidFolder(anim_autoGeneratedDataPath));


        string[] folders = AssetDatabase.GetSubFolders(textureDir);

        if (folders.Length > 0)
            folderSearch.AddSeparator("");


        foreach (var item in folders)
        {

            folderSearch.AddItem(new GUIContent($"Use [{Path.GetFileName(item)}]"), () =>
            {
                datas.Anim_folderId = AssetDatabase.AssetPathToGUID(item);
                RefreshAnimationFiles();
            }, checkmark: AssetDatabase.AssetPathToGUID(item) == datas.Anim_folderId);

        }


        GUILogiked.Panels.GUIDrawEditorIcon(folderSearch, GUILogiked.Panels.EditorIconType.EditDots);



        GUILayout.EndHorizontal();
    }

    void DrawAnimationFileList()
    {

        #region Gear Menu Inputs
        // GenericMenu animationInspectorGear = new GenericMenu();

        #endregion



        GUI.color = blackBackground;
        BeginVerticalToolPanel("Animations list", 230, expandHeight: false);
        animationFilesScrollView = GUILayout.BeginScrollView(animationFilesScrollView, false, false, GUILayout.ExpandWidth(true), GUILayout.ExpandHeight(false));



        string displayName;
        Match regResult;

        foreach (var anim in dataFolderAnimationsFiles)
        {

            if (anim == null) continue;

            GUILayout.BeginHorizontal(GUILayout.ExpandWidth(true));

            if (anim == selectedAnimation)

                GUI.enabled = false;


            displayName = anim.name;


            regResult = Regex.Match(displayName, regexAnimationName);

            if (regResult.Success)
                displayName = regResult.Groups[2].Value;

            if (GUILayout.Button(displayName, GUILogiked.Styles.Button_NoBackgroundButton, GUILayout.ExpandWidth(true), GUILayout.Height(23f)))
            {
                Animation_Select(anim);
            }
            GUI.enabled = true;

            Rect dest = new Rect();
            dest = GUILayoutUtility.GetLastRect();
            dest.width = 20f;
            dest.height = 20f;


            if (datas.TryGetAnimationCreationInforation(anim.GetGUID()) != null)
            {
                var icon = AssetDatabase.GetCachedIcon(anim.GetAssetPath(Logiked_AssetsExtention.PathFormat.AssetRelative));
                GUI.DrawTexture(dest, icon);
            }
            else
            {
                GUILogiked.Panels.GUIDrawEditorIcon(GUILogiked.Panels.EditorIconType.LockerWhite, dest);
            }



            GUILayout.EndHorizontal();


        }

        GUILayout.EndScrollView();

        GUILayout.Space(5);


        if (GUILayout.Button("Create animation"))
        {
            CreateAnimationButton();
        }

        GUILayout.EndVertical();
    }



    void UpdateAnimationHilightSprites()
    {
        HashSet<Sprite> toHighlight = new HashSet<Sprite>();
        HashSet<Sprite> toHighlight2 = new HashSet<Sprite>();

        if (selectedAnimation != null)
        {
            toHighlight.UnionWith(selectedAnimation.Sprites);


            if (selectedAnimation is Animation2DFileVariations)
            {
                var multi = selectedAnimation as Animation2DFileVariations;
                Sprite[] sprites;


                for (int x = 0; x < multi.SpritesVariations.Length; x++)
                {
                    sprites = multi.SpritesVariations[x].Sprites;
                    if (sprites == null) continue;
                    toHighlight2.UnionWith(sprites);

                }


            }
        }



        foreach (var s in spritesAll)
        {
            if (s == null) continue;

            s.isAnimSelected = toHighlight.Contains(s.linkedSpriteFile);
            s.isDirectionnalSelected = toHighlight2.Contains(s.linkedSpriteFile);

        }
    }

    /*
    [Obsolete()]
    void AnimationHighlightSprites(Sprite[] sprites, bool active)
    {
        SpriteMetaExtended sprite;

        foreach (var s in sprites)
        {
            if (s == null) continue;
            sprite = GetSpriteByName(s.name);
            if (sprite != null) sprite.isAnimSelected = active;
        }
    }*/

    const string regexAnimationName = "(.*?)_([^_]*)$";

    private void OnFocus()
    {
        if (text2d == null) return;
        RefreshAnimationFiles();
    }

    public void Animation_Select(Animation2DFile file)
    {
        RefreshAnimationFiles();
        GUI.FocusControl(null);

        UpdateAssetLabel(file);



        selectedAnimation = file;

        UpdateAnimationHilightSprites();

        RefreshAnimationPreview();

        if (selectedAnimation == null) return;


        anim_newRenameName = null;

        SetEditMode(EditMode.Animation);

        /*
        if (selectedAnimationEditor != null)
        {
            selectedAnimationEditor.CloseWindow();
            DestroyImmediate(selectedAnimationEditor);
        }

        selectedAnimationEditor = (Inspector_Animation2DFile)Editor.CreateEditorWithContext(new Object[] { selectedAnimation }, this, typeof(Inspector_Animation2DFile));
        selectedAnimationEditor.autoDrawPreview = false;
        */

        /*
        Editor refInspector = selectedAnimationEditor;
        Editor.CreateCachedEditor(selectedAnimation, typeof(Animation2DFile), ref refInspector);
        selectedAnimationEditor.autoDrawPreview = false;*/

    }

    public void Animation_RemoveSelected()
    {
        var toRemove = selectedAnimation;
        Animation_Select(null);
        RemoveAssetFromDataFolder(toRemove);

    }


    string anim_newRenameName;
    void DrawAnimationProcessor()
    {
        if (selectedAnimation == null) return;
        Meta2DAnimation preprocessorDatas = datas.TryGetAnimationCreationInforation(selectedAnimation.GetGUID());



        #region Gear Menu Inputs
        GenericMenu animationInspectorGear = new GenericMenu();

        animationInspectorGear.AddItem(new GUIContent("Reveal animation file"), false, () => ProjectBrowserReflection.SelectAssetInProjectWindow(selectedAnimation));
        animationInspectorGear.AddShortcut(KeyCode.F2, EventModifiers.Control);

        animationInspectorGear.AddItem(new GUIContent("Unselect"), false, () => Animation_Select(null));
        animationInspectorGear.AddShortcut(KeyCode.D, EventModifiers.Control);


        animationInspectorGear.AddSeparator("");
        animationInspectorGear.AddItem(new GUIContent("Select used sprites"), false, () => AnimContext_SelectCurrentAnimationSprite());
        animationInspectorGear.AddShortcut(KeyCode.A, EventModifiers.Control);

        animationInspectorGear.AddSeparator("");
        animationInspectorGear.AddItem(new GUIContent("Frames/Set selection to anim"), () => AnimContext_UpdateSelectionToAnim(), preprocessorDatas == null || preprocessorDatas.spriteSource != AnimationGenerationMode.None);
        animationInspectorGear.AddShortcut(KeyCode.E, EventModifiers.Control | EventModifiers.Shift);
        animationInspectorGear.AddItem(new GUIContent("Frames/Add selection to anim"), () => AnimContext_AddSelectionToAnim(), preprocessorDatas == null || preprocessorDatas.spriteSource != AnimationGenerationMode.None);
        animationInspectorGear.AddShortcut(KeyCode.E, EventModifiers.Control);
        animationInspectorGear.AddItem(new GUIContent("Frames/Remove selection from anim"), () => AnimContext_SubstractSelectionToAnim(), preprocessorDatas == null || preprocessorDatas.spriteSource != AnimationGenerationMode.None);
        animationInspectorGear.AddShortcut(KeyCode.R, EventModifiers.Control);

        animationInspectorGear.AddSeparator("");
        animationInspectorGear.AddItem(new GUIContent("Remove Item/Confirm"), false, () => Animation_RemoveSelected());
        animationInspectorGear.AddShortcut(KeyCode.Delete, EventModifiers.Control);
        #endregion

        if (selectedAnimation == null) return;


        BeginVerticalToolPanel("Animation Generation", 250, animationInspectorGear,
          () => GUILogiked.Panels.GUIDrawEditorIcon(() => ProjectBrowserReflection.SelectAssetInProjectWindow(selectedAnimation), GUILogiked.Panels.EditorIconType.Folder), false);




        GUILayout.Label("File name", GUILogiked.Styles.Text_Bold);

        GUILayout.BeginHorizontal();



        if (anim_newRenameName.IsNullOrEmpty())
        {
            EditorGUILayout.LabelField(selectedAnimation.name);
            GUILogiked.Panels.GUIDrawEditorIcon(() => anim_newRenameName = selectedAnimation.name, GUILogiked.Panels.EditorIconType.Gear);

        }
        else
        {

            var splitex = Regex.Match(anim_newRenameName, regexAnimationName);

            if (splitex.Success)
            {

                string lastPart = splitex.Groups[2].ToString();
                string firtsPart = splitex.Groups[1].ToString();

                firtsPart = EditorGUILayout.TextField(firtsPart, GUILayout.ExpandWidth(true));
                EditorGUILayout.LabelField("_", GUILayout.Width(10f));
                lastPart = EditorGUILayout.TextField(lastPart, GUILayout.ExpandWidth(true));

                anim_newRenameName = $"{firtsPart}_{lastPart}";
            }
            else
            {
                anim_newRenameName = EditorGUILayout.TextField(anim_newRenameName);
            }




            GUILogiked.Panels.GUIDrawEditorIcon(() =>
            {
                EditorGUIUtility.keyboardControl = 0;
                RemameAssetFromDataFolder(selectedAnimation, anim_newRenameName);
                EditorUtility.SetDirty(selectedAnimation);
                anim_newRenameName = null;
            },
            GUILogiked.Panels.EditorIconType.ConfirmChecked);

            GUILogiked.Panels.GUIDrawEditorIcon(() =>
            {
                EditorGUIUtility.keyboardControl = 0;
                anim_newRenameName = null;
            },
         GUILogiked.Panels.EditorIconType.RemoveCross);

        }

        GUILayout.EndHorizontal();





        GUILayout.Space(10);


        if (preprocessorDatas == null)
        {
            GUILayout.BeginVertical(GUILogiked.Styles.Box_HelpBox1, GUILayout.ExpandWidth(true));
            GUILayout.BeginHorizontal();

            var r = GUILayoutUtility.GetRect(32, 32);
            r.y += 5;

            GUILogiked.Panels.GUIDrawEditorIcon(GUILogiked.Panels.EditorIconType.Warning, r);


            GUILayout.Label("This animation was created from an other texture", GUILogiked.Styles.BaseText);
            GUILayout.EndHorizontal();

            GUILayout.Space(5f);

            if (GUILayout.Button("Open texture"))
            {
                //  var findTexture = selectedAnimation.Sprites.FirstOrDefault(m => m != null)?.texture;
                var findTexture = SearchWhoDeclaredThisAnimation(selectedAnimation.GetGUID());



                if (findTexture == null)
                {
                    findTexture = selectedAnimation.Sprites.FirstOrDefault(m => m != null)?.texture;

                    if (findTexture != null)
                    {
                        SetTexture(findTexture);
                        //Si l'animation n'est pas référencée, on l'ajoute dans la liste des animations crées par cette texture
                        if (datas.Anim_createdWithThisTexture.FirstOrDefault(m => m.AnimationGuid == selectedAnimation.GetGUID()) == null)
                        {
                            var metas = new Meta2DAnimation();
                            metas.AnimationGuid = selectedAnimation.GetGUID();
                            metas.spriteSource = AnimationGenerationMode.None;
                            datas.AddNewAnimationInformation(metas);
                            Debug.LogWarning("New animation added to this texture.");
                        }


                    }
                    else
                    {
                        Debug.LogError("This animation does not have any sprites, Associated texture not found.");

                    }
                }else
                {
                    SetTexture(findTexture);
                }
            }
            

            /*
            if (GUILayout.Button("Delete file"))
            {

            }*/

            GUILayout.EndVertical();
            GUILayout.EndVertical();
            return;

        }


        GUILayout.Label("Sprite Update Mode", GUILogiked.Styles.Text_Bold);
        if (selectedAnimation is Animation2DFileVariations)
        {
            preprocessorDatas.spriteSource = AnimationGenerationMode.FromSpecificLines;
            GUI.enabled = false;
        }
            preprocessorDatas.spriteSource = PropertyDrawerFinder.DrawPropertyOject(preprocessorDatas.spriteSource, new GUIContent(""));
        GUI.enabled = true;



        if (preprocessorDatas.spriteSource == AnimationGenerationMode.FromSpecificLines)
        {

            preprocessorDatas.lineStartIndex = PropertyDrawerFinder.DrawPropertyOject(preprocessorDatas.lineStartIndex, new GUIContent("Start line index"));
            preprocessorDatas.lineCount = PropertyDrawerFinder.DrawPropertyOject(preprocessorDatas.lineCount, new GUIContent("Numbre of lines"));

            preprocessorDatas.lineStartIndex = preprocessorDatas.lineStartIndex.Clamp(1, 999);
            preprocessorDatas.lineCount = preprocessorDatas.lineCount.Clamp(1, 999);
        }
        GUILayout.Space(10f);


        if (selectedAnimation is Animation2DFileVariations)
        {
            EditorGUI.BeginChangeCheck();

            GUILayout.Label("Multi Directionnal Settings", GUILogiked.Styles.Text_Bold);
            Animation2DFileVariations selectedAnimationDir = selectedAnimation as Animation2DFileVariations;
            selectedAnimationDir.DirectionCountMode = PropertyDrawerFinder.DrawPropertyOject(selectedAnimationDir.DirectionCountMode, new GUIContent("Direction Mode", "Number of different direction on this texture"));

            if (selectedAnimationDir.DirectionCountMode == VariationCountModeEnum.CustomVariationCount)
                selectedAnimationDir.CustomDirectionCount = PropertyDrawerFinder.DrawPropertyOject(selectedAnimationDir.CustomDirectionCount, new GUIContent("Count", "Number of different direction on this texture"));


            datas.MultiDirectionnalLineOffset = PropertyDrawerFinder.DrawPropertyOject(datas.MultiDirectionnalLineOffset, new GUIContent("Lines between directions", "Number of lines between each different direction animations"));

            if (EditorGUI.EndChangeCheck())
                UpdateAnimationHilightSprites();

        }



        GUILayout.Space(10f);


        GUI.enabled = preprocessorDatas.spriteSource != AnimationGenerationMode.None;
        if (GUILayout.Button("Cut and update animations"))
        {
            CutAndUpdateAnimationsSprites();
            UpdateAnimationHilightSprites();
        }
        GUI.enabled = true;


        GUILayout.EndVertical();

    }

    /// <summary>
    /// Get inside texture's metadata in assets which texture created this animation 
    /// </summary>
    /// <param name="guid">this ghuid of the animation</param>
    /// <returns></returns>
    Texture2D SearchWhoDeclaredThisAnimation(string guid)
    {
        var texList = AssetDatabase.FindAssets("t:texture2d", new string[] { Path.GetDirectoryName(texturePath) });
        string texPath;
        TextureImporter currentImpo;
        TextureMetadataExtension metas;

        foreach (var e in texList)
        {
            texPath = AssetDatabase.GUIDToAssetPath(e);

            //  if (AssetDatabase.GetMainAssetTypeAtPath(texPath) == typeof(Texture2D)) continue;

            currentImpo = AssetImporter.GetAtPath(texPath) as TextureImporter;

            metas = TextureMetadataExtension.DeserializeFromImporter(currentImpo, false);


            if (metas != null && metas.TryGetAnimationCreationInforation(guid) != null) return (Texture2D)AssetDatabase.LoadAssetAtPath(texPath, typeof(Texture2D));

        }


        return null;
    }


    private void CutAndUpdateAnimationsSprites()
    {
        spritesAll = CutAndUpdateAnimationsSprites(text2d, datas, textureImport);
        RefreshAnimationPreview();
    }

    /// <summary>
    /// Paroure toutes les anims utilisés par cette texture et re-remplis leur animations avec les sprites correspondant.
    /// </summary>
    public static List<SpriteMetaExtended> CutAndUpdateAnimationsSprites(Texture2D texture, TextureMetadataExtension metas, TextureImporter importer)
    {
        var newSprites = CuttingTool_HachTex(texture, metas, importer);

        var dats = metas.Anim_createdWithThisTexture;

        foreach (var dat in dats)
        {
            var path = AssetDatabase.GUIDToAssetPath(dat.AnimationGuid);

            if (path == null) continue;

            var anim = AssetDatabase.LoadMainAssetAtPath(path) as Animation2DFile;

            if (anim == null) continue;

            UpdateAnimationSheet(anim,metas, dat, newSprites);

            Debug.Log($"{anim.name} animation updated!");
        }

        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        return newSprites;
    }


    /// <summary>
    /// Re-remplis l'animations avec les sprites correspondant.
    /// </summary>
    static void UpdateAnimationSheet(Animation2DFile file, TextureMetadataExtension datas, Meta2DAnimation metas, List<SpriteMetaExtended> allSprites)
    {

        if (!(file is Animation2DFileVariations))
        {

            switch (metas.spriteSource)
            {
                case AnimationGenerationMode.None://L'anim n'a pas a etre actualisée
                    break;

                case AnimationGenerationMode.WholeFileAnimation:


                    file.Sprites = allSprites.Select(m => m.linkedSpriteFile).OrderBy(m => m.name).ToArray();
                    file.SetDirtyNow();
                    break;


                case AnimationGenerationMode.FromSpecificLines:

                    int minRange = metas.lineStartIndex;
                    int maxRange = minRange + metas.lineCount;
                    int pos;

                    List<Sprite> endSprites = new List<Sprite>();

                    foreach (var sp in allSprites)
                    {
                        pos = GetSpritegridCoordinates(sp.linkedSpriteFile.name).x;

                        if (pos >= minRange && pos < maxRange)
                            endSprites.Add(sp.linkedSpriteFile);
                    }

                    file.Sprites = endSprites.OrderBy(m => m.name).ToArray();
                    file.SetDirtyNow();

                    break;
            }
        }else if (file is Animation2DFileVariations)
        {
            var directionnalFile = file as Animation2DFileVariations;

            int minRange = metas.lineStartIndex;
            int maxRange = metas.lineCount;
            int pos;

            List<Sprite>[] directionalSprites = new List<Sprite>[directionnalFile.VariationCount];


            List<Sprite> currentPack = new List<Sprite>();

            allSprites = allSprites.OrderBy(m => m.linkedSpriteFile.name).ToList();

            Debug.Log(file.name);


            foreach (var sp in allSprites)
            {
                pos = (GetSpritegridCoordinates(sp.linkedSpriteFile.name).x - minRange);
                if (pos < 0) continue;
                int level = pos / datas.MultiDirectionnalLineOffset;

                pos = pos % datas.MultiDirectionnalLineOffset;


                if (pos >= 0 && pos < maxRange)
                {
                    if (level >= directionalSprites.Length) continue;

                    if (directionalSprites[level] == null)
                        directionalSprites[level] = new List<Sprite>();

                    directionalSprites[level].Add(sp.linkedSpriteFile);
                }
            }

            directionnalFile.SetSprites(directionalSprites.Select(m => m?.ToArray() ?? new Sprite[0]).ToArray() );
            file.SetDirtyNow();


        }


    }


    void RefreshAnimationPreview()
    {
        if(selectedAnimation == null)
        {
            animationPreviewReader = null;
            return;
        }
        animationPreviewReader = new Animation2DReader(selectedAnimation);
        animationPreviewReader.Play();
    }


    void DrawAnimationInspector()
    {
        Color normal = EditorStyles.label.normal.textColor;
        Color hover = EditorStyles.label.hover.textColor;


        EditorStyles.label.normal.textColor = Color.white;
        EditorStyles.label.hover.textColor = Color.white;




        if (selectedAnimation == null)//Anim destoyed
            return;



        BeginVerticalToolPanel("Result inspector", 250, null, otherIcons: () => GUILogiked.Panels.GUIDrawEditorIcon(() => ProjectBrowserReflection.SelectAssetInProjectWindow(selectedAnimation), GUILogiked.Panels.EditorIconType.Folder));


        EditorGUI.BeginChangeCheck();

        GUILayout.Space(5);
        GUILayout.Label("Settings", GUILogiked.Styles.Text_BigBold);

        selectedAnimation.Duration = PropertyDrawerFinder.DrawPropertyOject(selectedAnimation.Duration, new GUIContent(nameof(selectedAnimation.Duration)));
        selectedAnimation.LoopMode = PropertyDrawerFinder.DrawPropertyOject(selectedAnimation.LoopMode, new GUIContent(nameof(selectedAnimation.LoopMode)));

        GUILayout.Space(5);
        GUILayout.Label("Sprites", GUILogiked.Styles.Text_BigBold);

        animationInspectorScrollView = GUILayout.BeginScrollView(animationInspectorScrollView, GUILayout.Height(150), GUILayout.ExpandHeight(false));

        if (selectedAnimation is Animation2DFileVariations)
        {
            var an2 = selectedAnimation as Animation2DFileVariations;
            EditorGUILayout.HelpBox("Multi-directionnal animation : Take a look in unity inspector directly.", MessageType.Info, true);
                     
        }

        else if (selectedAnimation.Sprites.Length > 15)
        {
            EditorGUILayout.HelpBox("There is too much sprites to show. Take a look in unity inspector directly.", MessageType.Info, true);
        }
        else { 
            selectedAnimation.Sprites = PropertyDrawerFinder.DrawPropertyOject(selectedAnimation.Sprites, new GUIContent(nameof(selectedAnimation.Sprites)), GUILayout.Height(18f));
        }


        GUILayout.EndScrollView();
    

        if (EditorGUI.EndChangeCheck())
        {
            selectedAnimation.SetDirtyNow();
            RefreshAnimationPreview();
        }




        GUILayout.EndVertical();


            BeginVerticalToolPanel("Preview", 150, expandHeight: true);
        if (animationPreviewReader != null)
        {
            

            Inspector_Animation2DFile.DrawPreview(animationPreviewReader, GUILayoutUtility.GetRect(150,140)) ;
        }
        else
        {
            GUILayout.Label("Nothing to show");
        }

        GUILayout.EndVertical();


        /*BeginVerticalToolPanel("Result inspector", 250, null, otherIcons: () => GUILogiked.Panels.GUIDrawEditorIcon(() => ProjectBrowserReflection.SelectAssetInProjectWindow(selectedAnimation), GUILogiked.Panels.EditorIconType.Folder));


        try//Les scroll view font toujorus de la merde
        {
            animationInspectorScrollView = GUILayout.BeginScrollView(animationInspectorScrollView, GUILayout.MaxHeight(600));

            selectedAnimationEditor.OnInspectorGUI();


            GUILayout.EndScrollView();
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }


        GUILayout.EndVertical();


        BeginVerticalToolPanel("Preview", 140, expandHeight: true);
        selectedAnimationEditor.DrawSpritePreview(140);
        GUILayout.EndVertical();
        */


        EditorStyles.label.normal.textColor = normal;
        EditorStyles.label.hover.textColor = hover;
    }






    /// <summary>
    /// Selectionne les sprites appartenant à lanimation
    /// </summary>
    void AnimContext_SelectCurrentAnimationSprite()
    {
        DeselectSprites();
        foreach (var s in selectedAnimation.Sprites)
            SelectSpriteAdd(GetSpriteByName(s.name), false);
    }

    /// <summary>
    /// Applique les sprites selectionnées à l'animation. Attention aux animation ayant plusieurs fois le meme sprite. L'anim est passée dans un hashSet.
    /// </summary>
    void AnimContext_UpdateSelectionToAnim()
    {
        HashSet<Sprite> sprites = new HashSet<Sprite>(selectedAnimation.Sprites.ToList());
        selectedAnimation.Sprites = Array.ConvertAll(selectedSprites.ToArray(), m => m.linkedSpriteFile);
        Array.Sort(selectedAnimation.Sprites, (m, n) => m.name.CompareTo(n.name));
        Animation_Select(selectedAnimation);

    }
    /// <summary>
    /// Ajoute les sprites selectionnées à l'animation
    /// </summary>
    void AnimContext_AddSelectionToAnim()
    {
        HashSet<Sprite> sprites = new HashSet<Sprite>(selectedAnimation.Sprites.ToList());
        for (int i = 0; i < selectedSprites.Count; i++)
            sprites.Add(selectedSprites.ElementAt(i).linkedSpriteFile);
        selectedAnimation.Sprites = sprites.ToArray();
        Array.Sort(selectedAnimation.Sprites, (m, n) => m.name.CompareTo(n.name));
        Animation_Select(selectedAnimation);
    }

    void AnimContext_SubstractSelectionToAnim()
    {
        HashSet<Sprite> sprites = new HashSet<Sprite>(selectedAnimation.Sprites.ToList());
        for (int i = 0; i < selectedSprites.Count; i++)
            sprites.Remove(selectedSprites.ElementAt(i).linkedSpriteFile);
        selectedAnimation.Sprites = sprites.ToArray();
        Animation_Select(selectedAnimation);
    }



    void DrawAnimationPreview(List<SpriteMetaExtended> sprites)
    {
        /*

        SpriteMetaExtended sprite = sprites[((int)(animationPreviewTimer * sprites.Count)).Cycle(sprites.Count)];
        float previewWidth = 100 * sprite.datas.rect.width / sprite.datas.rect.height;

        BeginVerticalTool("Preview", previewWidth);
    


        GUILayout.BeginHorizontal(GUILayout.Height(100), GUILayout.Width(previewWidth + 5));
        Rect previewRect = GUILayoutUtility.GetRect(0, 100);


        if (animationPreviewTimer > 1f) animationPreviewTimer = 0;

        previewRect.height = 100;
        previewRect.width = 100 * sprite.datas.rect.width / sprite.datas.rect.height;


        GUI.DrawTextureWithTexCoords(previewRect, tex2d, sprite.guiTextureRect);
        GUILayout.FlexibleSpace();
        GUILayout.EndHorizontal();

       if(GUILayout.Button("Create Animation"))
        {
            CreateAnimationFromSelection();
        }


        GUILayout.EndVertical();*/
    }



    public enum AnimationGenerationMode { None = 0, FromSpecificLines = 1, WholeFileAnimation = 2 }

    public void CreateMultiDirectionalAnimationFromSelection(Animation2DFileVariations.VariationCountModeEnum directionMode)
    {
        Animation2DFileVariations anim = ScriptableObject.CreateInstance<Animation2DFileVariations>();
        anim.name = "newDirAnim" + UnityEngine.Random.Range(0, 9999);
        anim.Sprites = Array.ConvertAll(selectedSprites.ToArray(), (m) => m.linkedSpriteFile);
        anim.DirectionCountMode = directionMode;
        ConfigCreatedAnimation(anim, AnimationGenerationMode.FromSpecificLines);
    }


    public void CreateAnimationFromSelection(AnimationGenerationMode generationMode)
    {
        Animation2DFile anim = ScriptableObject.CreateInstance<Animation2DFile>();
        anim.name = "newAnim" + UnityEngine.Random.Range(0, 9999);
        anim.Sprites = Array.ConvertAll(selectedSprites.ToArray(), (m) => m.linkedSpriteFile);
        ConfigCreatedAnimation(anim, generationMode);
    }


    public void ConfigCreatedAnimation(Animation2DFile anim, AnimationGenerationMode generationMode)
    {
        SetEditMode(EditMode.Animation);
  

        SaveAssetsToDataFolder(anim);

        var guid = AssetDatabase.GUIDFromAssetPath(anim.GetAssetPath(Logiked_AssetsExtention.PathFormat.AssetRelative));


        Meta2DAnimation newAnim = new Meta2DAnimation();

        newAnim.AnimationGuid = guid.ToString();
        newAnim.spriteSource = generationMode;

        switch (generationMode)
        {

            case AnimationGenerationMode.FromSpecificLines:
                var selecetdLines = GetSelectedLineRange();
                newAnim.lineStartIndex = selecetdLines.x;
                newAnim.lineCount = selecetdLines.y;
                break;

        }

        datas.AddNewAnimationInformation(newAnim);
        UpdateAnimationSheet(anim, datas, newAnim, spritesAll);
        Animation_Select(anim);
        UpdateAnimationHilightSprites();
    }


    #endregion

    /// <summary>
    /// Retourne les lignes selectionnées au format [linesDeDépart, Nombre de lignes]
    /// </summary>
    Vector2Int GetSelectedLineRange()
    {
        var spriteNames = selectedSprites.Select(m => m.datas.name).Select(m => GetSpritegridCoordinates(m)).ToArray();

        int minSpriteX = spriteNames.Min(m => m.x);
        int maxSpriteX = spriteNames.Max(m => m.x);


        return new Vector2Int(minSpriteX, (maxSpriteX - minSpriteX) + 1);
    }



    /// <summary>
    /// Récupere les positions X et Y du sprite par son nom
    /// </summary>
    private static Vector2Int GetSpritegridCoordinates(string spritename)
    {
        Assert.IsNotNull(spritename);

        var match = spritename.Split('_');



        if (match.Length < 3)
        {

            Debug.LogError($"Sprite with name {spritename} is in the wrong format. Texture mush be Re-Cut");
            return Vector2Int.zero;
        }

        int intX;
        int intY;


        if (!int.TryParse(match.GetCyclic(-2), out intX) || !int.TryParse(match.GetCyclic(-1), out intY))
        {
            Debug.LogError($"Error trying parsing X and Y values in {spritename}");
            return Vector2Int.zero;
        }


        return new Vector2Int(intX, intY);

    }


    #region TOOL - format


    bool isTextureModified = false;



    void DrawFormatTool_Init()
    {
        //  imp = AssetImporter.GetAtPath(text2d.GetAssetPath(Logiked_AssetsExtention.PathFormat.AssetRelative)) as TextureImporter;

    }

    void DrawFormatTool()
    {



        GenericMenu pressetFinder = new GenericMenu();

        var defPresset = LogikedPlugin_2DTools.Instance?.TextureMainImportPresset;
        var presName = defPresset==null ? "Null" : defPresset.name;

        pressetFinder.AddItem(new GUIContent("None"), () => {
            datas.ImportPressedGuid = "0";
            AutoFormat();
        }, false, currentPresset == null);

        pressetFinder.AddItem(new GUIContent($"{presName}(Default)"), () => {
            datas.ImportPressedGuid = "";
            AutoFormat();
        }, defPresset == null, currentPresset == defPresset);

        foreach (var pres in LogikedPlugin_2DTools.Instance.OtherImportPressets)
        {
            if (pres == null) continue;

            pressetFinder.AddItem(new GUIContent(pres.name), () =>
            {
                datas.ImportPressedGuid = pres.GetGUID();
                AutoFormat();
            }, false, currentPresset == pres);
        }



        GUILayout.BeginHorizontal();
        GUILayout.Label("Import presset");
        GUILayout.Space(5);

        EditorGUI.BeginChangeCheck();

        currentPresset = (Preset)EditorGUILayout.ObjectField(currentPresset, typeof(Preset), allowSceneObjects: false, GUILayout.Width(150));
        GUILogiked.Panels.GUIDrawEditorIcon(pressetFinder, GUILogiked.Panels.EditorIconType.EditDots);

        GUILayout.FlexibleSpace();

        GUILayout.EndHorizontal();


        if (currentPresset != null)
            datas.ImportPressedGuid = currentPresset.GetGUID();
        else
            datas.ImportPressedGuid = "0";

        if (EditorGUI.EndChangeCheck())
            AutoFormat();



        GUI.enabled = !usesImportSettings;

        GUILayout.BeginHorizontal();
        DrawFormatMainPannel();
        DrawFormatOptionalPannel();
        GUILayout.EndHorizontal();

    }

    void DrawFormatMainPannel()
    {


        BeginVerticalToolPanel("Main import settings", 300);


        int errCount = 0;


        void OnParamError()
        {
            GUI.color = Color.red;
            errCount++;
        }



        if (textureImport.textureType != TextureImporterType.Sprite) OnParamError();
        textureImport.textureType = PropertyDrawerFinder.DrawPropertyOject(textureImport.textureType, new GUIContent(nameof(TextureImporter.textureType)), null);
        GUI.color = Color.white;

        if (!textureImport.isReadable) OnParamError();
        textureImport.isReadable = PropertyDrawerFinder.DrawPropertyOject(textureImport.isReadable, new GUIContent(nameof(TextureImporter.isReadable)), null);
        GUI.color = Color.white;


        //GUI.enabled = false;
        //if (textureImport.spriteImportMode != SpriteImportMode.Multiple) OnParamError();
        textureImport.spriteImportMode = PropertyDrawerFinder.DrawPropertyOject(textureImport.spriteImportMode, new GUIContent(nameof(TextureImporter.spriteImportMode)), null);
        //GUI.color = Color.white;
        //GUI.enabled = !usesDefaultImportSetting;



        if (errCount > 0)
        {
            GUILayout.BeginVertical(GUILogiked.Styles.Box_HelpBox1);
            GUILayout.BeginHorizontal();

            var r = GUILayoutUtility.GetRect(32, 32);

            GUILogiked.Panels.GUIDrawEditorIcon(GUILogiked.Panels.EditorIconType.Warning, r);
            GUILayout.Label("Some parameters must be set before using sprite cutter.");
            GUILayout.EndHorizontal();

            if (GUILayout.Button("Fix"))
            {
                textureImport.isReadable = true;
                textureImport.textureType = TextureImporterType.Sprite;
                textureImport.spriteImportMode = SpriteImportMode.Multiple;
                FormatReimport();
            }
            GUILayout.EndVertical();

        }




        GUILayout.EndVertical();

    }

    void DrawFormatOptionalPannel()
    {
        BeginVerticalToolPanel("Design settings", 300);

        EditorGUI.BeginChangeCheck();

        textureImport.filterMode = (FilterMode)PropertyDrawerFinder.DrawPropertyOject(textureImport.filterMode, new GUIContent(nameof(TextureImporter.filterMode)), GUILayout.Width(250f));

        textureImport.spritePixelsPerUnit = (float)PropertyDrawerFinder.DrawPropertyOject(textureImport.spritePixelsPerUnit, new GUIContent(nameof(TextureImporter.spritePixelsPerUnit)), GUILayout.Width(250f));

        isTextureModified |= EditorGUI.EndChangeCheck();


        GUILayout.FlexibleSpace();

        GUI.enabled = isTextureModified;
        if (GUILayout.Button("Apply changes")) FormatReimport();
        GUI.enabled = !usesImportSettings;

        GUILayout.EndVertical();
    }



    bool usesImportSettings => currentPresset != null;

    void FormatReimport()
    {
        textureImport.SaveAndReimport();
        isTextureModified = false;
    }

    Preset currentPresset;

    public static Preset GetTexturePresset(TextureMetadataExtension metas)
    {


        if (metas.ImportPressedGuid.IsNullOrEmpty())
        {
            if (LogikedPlugin_2DTools.Instance.TextureMainImportPresset != null)
                metas.ImportPressedGuid = LogikedPlugin_2DTools.Instance.TextureMainImportPresset.GetGUID();
            else
            {
                Debug.LogError("You have to specify a default presset in the LogikedConfigurationWindows to setup correclty the project");
                metas.ImportPressedGuid = "0";
            }
        }

        if (metas.ImportPressedGuid == "0")
        {
            return null;
        }

        return (Preset)AssetDatabase.LoadMainAssetAtPath(AssetDatabase.GUIDToAssetPath(metas.ImportPressedGuid));
    }


    private void AutoFormat(bool forceReimport = false)
    {
        currentPresset = AutoFormat(textureImport, datas, forceReimport);
    }

    /// <summary>
    /// Appliquer un pressset d'import settings spécifique
    /// </summary>
    public static Preset AutoFormat(TextureImporter importer, TextureMetadataExtension metas, bool forceReimport = false)
    {
        Preset currentPresset = GetTexturePresset(metas);

        var needApply = false;

        needApply |= importer.isReadable != true;


        if (currentPresset != null)
        {
            SpriteMetaData[] saveSpriteSheet = importer.spritesheet;//Duplicate
            SpriteImportMode saveImportedMode = importer.spriteImportMode;
            if (saveImportedMode == SpriteImportMode.None) saveImportedMode = SpriteImportMode.Single;
            var textureUserDatas = importer.userData;

            currentPresset.ApplyTo(importer);

            importer.spritesheet = saveSpriteSheet;
            importer.spriteImportMode = saveImportedMode;
            importer.userData = textureUserDatas;
            metas.Serialize();
        }

        if (needApply || forceReimport)
            importer.SaveAndReimport();

        return currentPresset;
    }


    #endregion


    #region TOOL - Workspace

    bool format_datafoldExist = false;
    string format_animatorPath = null;

    void DrawWorkspaceTool_Init()
    {
        format_datafoldExist = Directory.Exists(currentDataPath);
        format_animatorPath = null;
        var f = AssetDatabase.FindAssets("t:" + typeof(AnimatorController2DFile).Name, new string[] { currentDataPath });
        if (f.Length > 0)
            format_animatorPath = AssetDatabase.GUIDToAssetPath(f[0]);
    }


    void DrawWorkspaceTool() {

        GUILayout.BeginHorizontal();
        DrawWorkspaceTool_Animator();

        DrawWorkspaceTool_Textures();
        GUILayout.EndHorizontal();

    }

    void DrawWorkspaceTool_Textures() {

        BeginVerticalToolPanel("Normal map & Materials", 300);

        EditorGUILayout.HelpBox("Future developpement idea : Dynamic Normal map texture file + Associated Material.", MessageType.Info);

        GUILayout.EndVertical();
    }

    void DrawWorkspaceTool_Animator()
    {

        BeginVerticalToolPanel("Animator", 300);

        if (format_animatorPath.IsNullOrEmpty())
        {
            if (GUILayout.Button("Create Animator2D")) CreateAnimator2D();
        }
        else
        {

            GUILayout.BeginHorizontal();

            if (GUILayout.Button(Path.GetFileName(format_animatorPath), GUILayout.ExpandWidth(true), GUILayout.Height(38)))
            {
                ProjectBrowserReflection.SelectObjectInUnityInspector(format_animatorPath);
            }

            // EditorGUIUtility.SetIconSize(new Vector2(100, 30));
            Rect dest = GUILayoutUtility.GetLastRect();
            dest.width = 35;
            dest.height = 35;
            dest.y += 2;
            var icon = AssetDatabase.GetCachedIcon(format_animatorPath);
            GUI.DrawTexture(dest, icon);

            GUILayout.EndHorizontal();

        }



        GUILayout.EndVertical();
    }

    void CreateAnimator2D()
    {
        //format_animatorPath = "-animator";
        AnimatorController2DFile controller = ScriptableObject.CreateInstance<AnimatorController2DFile>();
        controller.name = "-animator";
        SaveAssetsToDataFolder(controller);
        format_animatorPath = AssetDatabase.GetAssetPath(controller);
    }


    #endregion


    #endregion

    #region SELECTION - Sprite And Outline

    /// <summary>
    /// toute la partie selection de sprite a la souris.
    /// </summary>
    public void SelectEventSprites()
    {
        #region Fields

        int controlId = GUIUtility.GetControlID(FocusType.Passive);

        //Debug

        Rect spriteScreenRect;
        Rect mouseDragRect = new Rect();




        bool spriteClicked = false;
        SpriteMetaExtended sprite;
        bool click_left = false;

        #endregion

        #region Draggin selection




        switch (Event.current.GetTypeForControl(controlId))
        {


            case EventType.MouseUp:
                isMouseDraggingForSelection = false;
                break;

            case EventType.MouseDown:

                isMouseDraggingForSelection = false;

                if (isMouseOverTextureArea && Event.current.button == 0)
                {
                    mouseDragSelectionStart = Event.current.mousePosition;
                    GUIUtility.hotControl = controlId;
                    Event.current.Use();

                    isMouseDraggingForSelection = true;
                    click_left = true;

                }

                break;

        }




        if (isMouseDraggingForSelection)
        {
            mouseDragSelectionEnd = Event.current.mousePosition;
            mouseDragRect = new Rect(mouseDragSelectionStart, mouseDragSelectionEnd - mouseDragSelectionStart);
            Handles.DrawSolidRectangleWithOutline(mouseDragRect, new Color(0, 1f, 0f, 0.2f), new Color(0, 1f, 0f, 1f));

        }



        #endregion




        for (int i = 0; i < spritesAll.Count; i++)
        {

            sprite = spritesAll[i];
            UpdateSpriteData(sprite);
            spriteScreenRect = sprite.screenRect;
            spriteClicked = false;



            if (!isMouseDraggingForSelection && isMouseOverTextureArea && spriteScreenRect.Contains(Event.current.mousePosition))
            {
                sprite.isMouseOver = true;

                //If sprite clicked

                /*
                    if (!input_holdCtrl)
                        DeselectSprites();
                    spriteClicked = true;*/

            }
            else if (isMouseDraggingForSelection && mouseDragRect.Overlaps(spriteScreenRect, true))
                spriteClicked = true;
            else
                sprite.isMouseOver = false;


            if (spriteClicked)
            {
                SelectSpriteAdd(sprite, input_holdShift);
            }
        }


        if (click_left && !input_holdCtrl)
            DeselectSprites();

        #endregion
    }

    /// <summary>
    /// Affichage des outline de sprites
    /// </summary>
    void DrawSpriteOutlines()
    {
        float ontlineTickness;
        Rect screenRect;
        Color selectedColor;
        needRepaint = true;

        foreach (var sprite in spritesAll)
        {
            screenRect = sprite.screenRect;

            ontlineTickness = 1.5f;
            selectedColor = spriteBorderColor;

            if (sprite.isMouseOver)
            {
                selectedColor = spriteOverColor;
                ontlineTickness = 2.5f;
            }


            if (sprite.isSelected)
            {
                selectedColor = spriteSelectColor;
                ontlineTickness = 4.5f;

                GUI.DrawTexture(screenRect, spriteBorderTex, ScaleMode.StretchToFill, false, 0, selectedColor, ontlineTickness, 1);

                Handles.color = selectedColor;
                Handles.DrawSolidDisc(screenRect.min + screenRect.size * (new Vector2(sprite.datas.pivot.x, 1 - sprite.datas.pivot.y)), Vector3.forward, 8);
                Handles.color = Color.blue;
                Handles.DrawSolidDisc(screenRect.min + screenRect.size * (new Vector2(sprite.datas.pivot.x, 1 - sprite.datas.pivot.y)), Vector3.forward, 5);
                Handles.color = selectedColor;
            } else
                GUI.DrawTexture(screenRect, spriteBorderTex, ScaleMode.StretchToFill, false, 0, selectedColor, ontlineTickness, 1);



            if (sprite.isAnimSelected)
            {
                selectedColor = spriteAnimationColor;
                ontlineTickness = 4.5f;
                GUI.DrawTexture(screenRect, spriteBorderTex, ScaleMode.StretchToFill, false, 0, selectedColor, ontlineTickness, 1);
            }else
            if (sprite.isDirectionnalSelected)
            {
                selectedColor = spriteDirectionnalColor;
                ontlineTickness = 4.5f;
                GUI.DrawTexture(screenRect, spriteBorderTex, ScaleMode.StretchToFill, false, 0, selectedColor, ontlineTickness, 1);
            }


        
            



        }
    }

    #region SELECTION - Utils



    private void SelectSpriteAdd(SpriteMetaExtended sprite, bool remove)
    {

        if (sprite == null) return;

        if (remove)
        {
            selectedSprites.Remove(sprite);
            sprite.isSelected = false;
        }
        else
        {
            sprite.isSelected = true;
            selectedSprites.Add(sprite);
        }


    }



    private void DeselectSprites()
    {
        foreach (var s in selectedSprites)
            s.isSelected = false;

        selectedSprites.Clear();
    }
    #endregion



    void CreateAnimationButton_FillContextMenu(GenericMenu menu, string header)
    {
        menu.AddItem(new GUIContent($"{header}from selected sprites"), () => CreateAnimationFromSelection(AnimationGenerationMode.None), isDisabledMenu: selectedSprites.Count == 0); ;
        menu.AddSeparator("");
        menu.AddItem(new GUIContent($"{header}from whole file"), () => CreateAnimationFromSelection(AnimationGenerationMode.WholeFileAnimation));
        menu.AddItem(new GUIContent($"{header}from selected lines"), () => CreateAnimationFromSelection(AnimationGenerationMode.FromSpecificLines), isDisabledMenu: selectedSprites.Count == 0);
        menu.AddSeparator("");
        menu.AddItem(new GUIContent($"{header}from selected lines - 8 Directions "), () => CreateMultiDirectionalAnimationFromSelection(VariationCountModeEnum._8DirectionsAnimation), isDisabledMenu: selectedSprites.Count == 0);
        menu.AddItem(new GUIContent($"{header}from selected lines - 4 Directions "), () => CreateMultiDirectionalAnimationFromSelection(VariationCountModeEnum._4DirectionsAnimation), isDisabledMenu: selectedSprites.Count == 0);
    }

    void CreateAnimationButton()
    {

        GenericMenu createAnimationMode = new GenericMenu();
        CreateAnimationButton_FillContextMenu(createAnimationMode, "Create animation - ");
        createAnimationMode.ShowAsContext();
        /*
                SetEditMode(EditMode.Animation);
                CreateAnimationFromSelection();*/
    }

    #region SELECTION - Sprite inspector
    /// <summary>
    /// Draws the selected sprite inspector.
    /// </summary>
    void DrawInspectorWindow(int id)
    {



        List<SpriteMetaExtended> sort = selectedSpritesSorted;



        if (sort.Count >= 1)
        {
            if (GUILayout.Button("Create animation"))
            {
                CreateAnimationButton();
            }
        }


        // try//Sinon unity genere des erreurs de merde
        //  {
        inspectorScrollPosition = GUILayout.BeginScrollView(inspectorScrollPosition, false, false, GUILayout.ExpandHeight(true));
        for (int i = 0; i < sort.Count; i++)
            DrawSpritesInspector(sort[i]);
        GUILayout.EndScrollView();
        /* }
         catch (Exception e)
         {

         }
         */

        return;

    }

    void DrawSpritesInspector(SpriteMetaExtended sprite)
    {

        GUILayout.BeginVertical("box");
        GUILayout.BeginHorizontal();
        Rect previewRect = GUILayoutUtility.GetRect(50, 50);
        GUI.DrawTextureWithTexCoords(previewRect, text2d, sprite.guiTextureRect);
        GUILayout.FlexibleSpace();
        GUILayout.Label(sprite.datas.name);

        GUILayout.EndHorizontal();

        GUILayout.EndVertical();


        return;
    }
    #endregion



    #region Other events

    float autoSaveCooldown;

    private void Update()
    {


        switch (selectedTool)
        {
            case EditMode.Animation:
             //   saveMillis = 
           //     animationPreviewTimer += Time.unscaledDeltaTime;
            break;
        }


        if(text2d != null && datas.linkedImporter == null)
        {
            datas.linkedImporter = textureImport;//Oblilgatoire parce que ce champ n'est pas serializable
        }

        autoSaveCooldown += Time.deltaTime;

        if(autoSaveCooldown > 3f)//Enregistrement automatique toute les 3 secondes
        {
            SaveMetaDatas();
            autoSaveCooldown = 0f;
        }

    }


    private void OnDestroy()
    {
        /*
        if (selectedAnimationEditor != null)
        {
            selectedAnimationEditor.CloseWindow();
            DestroyImmediate(selectedAnimationEditor);
        }*/

        SaveMetaDatas();
    }


    #endregion

}


#endif